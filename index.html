<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Phase & Mel Spectrogram Analyzer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        h1 { margin-bottom: 10px; font-size: 1.5rem; }
        .controls {
            display: flex;
            gap: 20px;
            background: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        button {
            padding: 10px 20px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { background-color: #005f9e; }
        button:disabled { background-color: #444; cursor: not-allowed; }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label { font-size: 0.9rem; color: #aaa; }
        select, input[type="range"] {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 4px;
        }
        
        #canvas-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 1px solid #333;
        }
        canvas { display: block; background-color: black; }
        
        .legend {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #888;
            max-width: 800px;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>All-in-One Audio Analysis</h1>

    <div class="controls">
        <button id="startBtn">Start Microphone</button>
        
        <div class="control-group">
            <label for="modeSelect">Visualization Mode</label>
            <select id="modeSelect">
                <option value="A">Mode A: 3-Channel (Mag/Cos/Sin)</option>
                <option value="B">Mode B: Mel Spectrogram</option>
            </select>
        </div>

        <div class="control-group" id="threshGroup">
            <label for="threshold">Phase Threshold (0 - 255)</label>
            <input type="range" id="threshold" min="0" max="100" value="4">
            <span id="threshVal" style="font-size: 0.8em; color: #888;">10%</span>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="mainCanvas" width="800" height="400"></canvas>
    </div>

    <div class="legend" id="legendText">
        Mode A: R = Magnitude (Mel), G = Cos(Phase), B = Sin(Phase).
    </div>

<script>
/**
 * Simple FFT Implementation (Cooley-Tukey)
 */
class SimpleFFT {
    constructor(bufferSize) {
        this.bufferSize = bufferSize;
        this.reverseTable = new Uint32Array(bufferSize);
        this.sinTable = new Float32Array(bufferSize);
        this.cosTable = new Float32Array(bufferSize);

        let limit = 1;
        let bit = bufferSize >> 1;
        let i;

        while (limit < bufferSize) {
            for (i = 0; i < limit; i++) {
                this.reverseTable[i + limit] = this.reverseTable[i] + bit;
            }
            limit = limit << 1;
            bit = bit >> 1;
        }

        for (i = 0; i < bufferSize; i++) {
            this.sinTable[i] = Math.sin(-Math.PI / i);
            this.cosTable[i] = Math.cos(-Math.PI / i);
        }
    }

    calculate(buffer) {
        const k = Math.floor(Math.log(this.bufferSize) / Math.LN2);
        const bufferSize = this.bufferSize;
        const real = new Float32Array(bufferSize);
        const imag = new Float32Array(bufferSize);
        
        for (let i = 0; i < bufferSize; i++) {
            const window = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (bufferSize - 1)));
            real[i] = buffer[this.reverseTable[i]] * window;
            imag[i] = 0;
        }

        let halfSize = 1;
        while (halfSize < bufferSize) {
            const phaseShiftStepReal = Math.cos(-Math.PI / halfSize);
            const phaseShiftStepImag = Math.sin(-Math.PI / halfSize);
            
            let currentPhaseShiftReal = 1;
            let currentPhaseShiftImag = 0;

            for (let fftStep = 0; fftStep < halfSize; fftStep++) {
                for (let i = fftStep; i < bufferSize; i += 2 * halfSize) {
                    const off = i + halfSize;
                    const tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
                    const ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

                    real[off] = real[i] - tr;
                    imag[off] = imag[i] - ti;
                    real[i] += tr;
                    imag[i] += ti;
                }
                const tmpReal = currentPhaseShiftReal;
                currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
                currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
            }
            halfSize <<= 1;
        }
        return { real, imag };
    }
}

// --- App Logic ---

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const startBtn = document.getElementById('startBtn');
const modeSelect = document.getElementById('modeSelect');
const thresholdSlider = document.getElementById('threshold');
const threshVal = document.getElementById('threshVal');
const legendText = document.getElementById('legendText');

let audioCtx;
let source;
let scriptNode;
let fft;
let isRunning = false;

// --- FIXED CONFIG ---
const BUFFER_SIZE = 4096; // 增加 Buffer Size 以支持更高的 Mel 分辨率
const MEL_BANDS = 400;    // 必须等于 Canvas Height (400)
const MIN_FREQ = 20;
const MAX_FREQ = 8000;    

let melMap = []; 

const tempCanvas = document.createElement('canvas');
tempCanvas.width = canvas.width;
tempCanvas.height = canvas.height;
const tempCtx = tempCanvas.getContext('2d');

thresholdSlider.addEventListener('input', (e) => {
    threshVal.innerText = e.target.value + '%';
});

modeSelect.addEventListener('change', (e) => {
    if(e.target.value === 'A') {
        legendText.innerText = "Mode A: R=Mag, G=Cos(Phase), B=Sin(Phase). Low amplitude forces Phase=0.";
        document.getElementById('threshGroup').style.opacity = '1';
    } else {
        legendText.innerText = "Mode B: Standard Mel Spectrogram (Color = Magnitude)";
        document.getElementById('threshGroup').style.opacity = '0.3';
    }
});

function hzToMel(hz) {
    return 2595 * Math.log10(1 + hz / 700);
}

function melToHz(mel) {
    return 700 * (Math.pow(10, mel / 2595) - 1);
}

function createMelFilterBank(sampleRate, bufferSize) {
    const filters = [];
    const minMel = hzToMel(MIN_FREQ);
    const maxMel = hzToMel(MAX_FREQ);
    const melStep = (maxMel - minMel) / (MEL_BANDS + 1);

    for (let m = 0; m < MEL_BANDS; m++) {
        const startMel = minMel + m * melStep;
        const centerMel = minMel + (m + 1) * melStep;
        const endMel = minMel + (m + 2) * melStep;
        
        const startHz = melToHz(startMel);
        const centerHz = melToHz(centerMel);
        const endHz = melToHz(endMel);

        const freqPerBin = sampleRate / bufferSize;
        let startBin = Math.floor(startHz / freqPerBin);
        let centerBin = Math.floor(centerHz / freqPerBin);
        let endBin = Math.floor(endHz / freqPerBin);

        // Safety check: ensure we capture at least one bin
        if (endBin <= startBin) endBin = startBin + 1;
        if (centerBin < startBin) centerBin = startBin;

        filters.push({ startBin, centerBin, endBin });
    }
    return filters;
}

startBtn.addEventListener('click', async () => {
    if (isRunning) return;
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const sampleRate = audioCtx.sampleRate;
        
        source = audioCtx.createMediaStreamSource(stream);
        
        scriptNode = audioCtx.createScriptProcessor(BUFFER_SIZE, 1, 1);
        
        fft = new SimpleFFT(BUFFER_SIZE);
        melMap = createMelFilterBank(sampleRate, BUFFER_SIZE);

        scriptNode.onaudioprocess = (audioProcessingEvent) => {
            const inputBuffer = audioProcessingEvent.inputBuffer;
            const inputData = inputBuffer.getChannelData(0);
            processAudio(inputData);
        };

        source.connect(scriptNode);
        scriptNode.connect(audioCtx.destination); 
        
        startBtn.disabled = true;
        startBtn.innerText = "Running...";
        isRunning = true;
        
    } catch (err) {
        console.error("Error accessing microphone:", err);
        alert("Microphone access denied or error occurred.");
    }
});

function processAudio(timeData) {
    const { real, imag } = fft.calculate(timeData);
    
    const imgData = ctx.createImageData(1, MEL_BANDS);
    const data = imgData.data;
    
    const mode = modeSelect.value;
    const thresholdPercent = parseInt(thresholdSlider.value);
    
    // Normalize factor (adjusted for larger buffer)
    const scalar = 200 / BUFFER_SIZE; 

    for (let i = 0; i < MEL_BANDS; i++) {
        const filter = melMap[i];
        
        let magSum = 0;
        let maxBinVal = -1;
        let maxBinIndex = filter.centerBin;

        for (let b = filter.startBin; b < filter.endBin; b++) {
            if (b >= real.length / 2) break;
            const m = Math.sqrt(real[b]*real[b] + imag[b]*imag[b]);
            magSum += m;
            
            if (m > maxBinVal) {
                maxBinVal = m;
                maxBinIndex = b;
            }
        }
        
        let mag = Math.log1p(magSum * scalar) * 50; 
        mag = Math.min(255, Math.max(0, mag));

        // Get Phase from dominant bin
        const re = real[maxBinIndex] || 0;
        const im = imag[maxBinIndex] || 0;
        let phase = Math.atan2(im, re); 
        
        // Invert Y axis so low freq is at bottom
        const pixelIndex = (MEL_BANDS - 1 - i) * 4;

        if (mode === 'A') {
            if (mag < (thresholdPercent * 2.55)) { 
                phase = 0;
            }

            const valCos = Math.cos(phase);
            const valSin = Math.sin(phase);

            const g = Math.floor((valCos + 1) * 127.5);
            const b = Math.floor((valSin + 1) * 127.5);
            
            data[pixelIndex] = mag;     // R
            data[pixelIndex + 1] = g;   // G
            data[pixelIndex + 2] = b;   // B
            data[pixelIndex + 3] = 255; 
        } else {
            const r = mag * 1.5;
            const g = (mag - 100) * 2;
            const b = (mag - 180) * 4;
            
            data[pixelIndex] = r;
            data[pixelIndex + 1] = g;
            data[pixelIndex + 2] = b;
            data[pixelIndex + 3] = 255;
        }
    }

    tempCtx.drawImage(canvas, 0, 0);
    ctx.drawImage(tempCanvas, -1, 0);
    ctx.putImageData(imgData, canvas.width - 1, 0);
}
</script>
</body>
</html>
